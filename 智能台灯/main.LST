C51 COMPILER V9.00   MAIN                                                                  05/05/2023 21:19:00 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          
   4          #define uchar unsigned char             // 以后unsigned char就可以用uchar代替
   5          #define uint  unsigned int              // 以后unsigned int 就可以用uint 代替
   6          
   7          
   8          sbit LED     = P2^0;                                    // 模式指示灯，亮是自动模式，灭是手动模式
   9          sbit Lamp    = P1^0;                                    // 台灯控制引脚
  10          sbit Key1    = P1^2;                                    // 按键1，模式切换按键
  11          sbit Key2    = P1^3;                                    // 按键2，亮度减少按键
  12          sbit Key3    = P1^4;                                    // 按键3，亮度增加按键
  13          sbit ADC_CS  = P2^1;                                    // ADC0832的CS引脚
  14          sbit ADC_CLK = P2^2;                                    // ADC0832的CLK引脚
  15          sbit ADC_DAT = P2^3;                                    // ADC0832的DI/DO引脚
  16          sbit Module  = P1^1;                                    // 人体红外检测模块
  17          
  18          
  19          uchar gCount=0;                                                         // 全局计数变量
  20          uchar gIndex;                                                                   // 亮度变量，0是最暗，9是最亮，一共10档
  21          uint  gTime=0;                                                          // 计时变量，用于计时多久没检测到有人
  22          
  23          
  24          
  25          /*********************************************************/
  26          // 毫秒级的延时函数，time是要延时的毫秒数
  27          /*********************************************************/
  28          void DelayMs(uint time)
  29          {
  30   1          uint i,j;
  31   1          for(i=0; i<time; i++)
  32   1              for(j=0; j<112; j++);
  33   1      }
  34          
  35          
  36          
  37          /*********************************************************/
  38          // ADC0832的时钟脉冲
  39          /*********************************************************/
  40          void WavePlus()
  41          {
  42   1          _nop_();
  43   1          ADC_CLK = 1;
  44   1          _nop_();
  45   1          ADC_CLK = 0;
  46   1      }
  47          
  48          
  49          
  50          /*********************************************************/
  51          // 获取指定通道的A/D转换结果
  52          /*********************************************************/
  53          uchar Get_ADC0832()
  54          {
  55   1          uchar i;
C51 COMPILER V9.00   MAIN                                                                  05/05/2023 21:19:00 PAGE 2   

  56   1          uchar dat1=0;
  57   1          uchar dat2=0;
  58   1      
  59   1          ADC_CLK = 0;                                // 电平初始化
  60   1          ADC_DAT = 1;
  61   1          _nop_();
  62   1          ADC_CS = 0;
  63   1          WavePlus();                                 // 起始信号
  64   1          ADC_DAT = 1;
  65   1          WavePlus();                                 // 通道选择的第一位
  66   1          ADC_DAT = 0;
  67   1          WavePlus();                                 // 通道选择的第二位
  68   1          ADC_DAT = 1;
  69   1      
  70   1          for(i=0; i<8; i++)          // 第一次读取
  71   1          {
  72   2              dat1<<=1;
  73   2              WavePlus();
  74   2              if(ADC_DAT)
  75   2                  dat1=dat1|0x01;
  76   2              else
  77   2                  dat1=dat1|0x00;
  78   2          }
  79   1      
  80   1          for(i=0; i<8; i++)          // 第二次读取
  81   1          {
  82   2              dat2>>= 1;
  83   2              if(ADC_DAT)
  84   2                  dat2=dat2|0x80;
  85   2              else
  86   2                  dat2=dat2|0x00;
  87   2              WavePlus();
  88   2          }
  89   1      
  90   1          _nop_();                                            // 结束此次传输
  91   1          ADC_DAT = 1;
  92   1          ADC_CLK = 1;
  93   1          ADC_CS  = 1;
  94   1      
  95   1          if(dat1==dat2)                      // 返回采集结果
  96   1              return dat1;
  97   1          else
  98   1              return 0;
  99   1      }
 100          
 101          
 102          
 103          /*********************************************************/
 104          // 定时器初始化及串口初始化
 105          /*********************************************************/
 106          void TimerInit()
 107          {
 108   1      
 109   1      
 110   1      
 111   1          TMOD=0x21;                                  // 定时器1为工作方式2，定时器0为工作方式1 
 112   1          SM0=0;
 113   1          SM1=1;
 114   1          TH0  = 252;                                 // 给定时器0的TH0装初值
 115   1          TL0  = 24;                                  // 给定时器0的TL0装初值
 116   1          TR0=1;
 117   1          IE=0X82;
C51 COMPILER V9.00   MAIN                                                                  05/05/2023 21:19:00 PAGE 3   

 118   1      
 119   1          TH1=0xfd;                                    //253
 120   1          TL1=0xfd;
 121   1          SCON=0x50;                                  //串口为工作方式1,REN=1允许串口接受数据
 122   1          PCON=0x00;                                  //SMOD=0
 123   1          IP=0x10;                                //串口通信为高优先级
 124   1          TR1=1;
 125   1          ES = 1;
 126   1          EA=1;
 127   1      }
 128          
 129          
 130          
 131          /*********************************************************/
 132          // 手动控制
 133          /*********************************************************/
 134          void ManualControl()
 135          {
 136   1          // 亮度减少
 137   1          if(Key2==0)                                 // 如果按键2被按下去
 138   1          {
 139   2              if(gIndex>0)                    // 只要当前亮度不为最低才能减少亮度
 140   2              {
 141   3                  gIndex--;                           // 亮度降低一档
 142   3                  DelayMs(300);               // 延时0.3秒
 143   3              }
 144   2          }
 145   1      
 146   1          // 亮度增加
 147   1          if(Key3==0)                                 // 如果按键3被按下去
 148   1          {
 149   2              if(gIndex<9)                    // 只要当前亮度不为最高才能增加亮度
 150   2              {
 151   3                  gIndex++;                           // 亮度增加一档
 152   3                  DelayMs(300);               // 延时0.3秒
 153   3              }
 154   2          }
 155   1      }
 156          
 157          
 158          
 159          /*********************************************************/
 160          // 自动控制
 161          /*********************************************************/
 162          void AutoControl(uchar num)
 163          {
 164   1          if(num<59)                                                                                                          // 最暗
 165   1              gIndex=0;
 166   1          else if((num>65)&&(num<81))                                         // 第二亮
 167   1              gIndex=1;
 168   1          else if((num>87)&&(num<103))                                        // 第三亮
 169   1              gIndex=2;
 170   1          else if((num>109)&&(num<125))
 171   1              gIndex=3;
 172   1          else if((num>131)&&(num<147))
 173   1              gIndex=4;
 174   1          else if((num>153)&&(num<169))
 175   1              gIndex=5;
 176   1          else if((num>175)&&(num<191))
 177   1              gIndex=6;
 178   1          else if((num>197)&&(num<213))
 179   1              gIndex=7;
C51 COMPILER V9.00   MAIN                                                                  05/05/2023 21:19:00 PAGE 4   

 180   1          else if((num>219)&&(num<235))
 181   1              gIndex=8;
 182   1          else if(num>241)                                                                             // 最亮
 183   1              gIndex=9;
 184   1      }
 185          
 186          
 187          
 188          /*********************************************************/
 189          // 主函数
 190          /*********************************************************/
 191          void main()
 192          {
 193   1          uchar ret;
 194   1      
 195   1          TimerInit();                                        // 定时器初始化及串口初始化
 196   1      
 197   1          LED=0;                                                              // 指示灯点亮(自动模式指示灯)
 198   1          ret=Get_ADC0832();          // 获取AD采集结果(环境光照强度)
 199   1          AutoControl(ret);                   // 上电先进行一次自动亮度控制
 200   1          AutoControl(ret+7);
 201   1      
 202   1          while(1)
 203   1          {
 204   2              /* 模式切换控制 */
 205   2              if(Key1==0)                                     // 如果按键1被按下去
 206   2              {
 207   3                  LED=~LED;                                   // 切换LED灯状态
 208   3                  DelayMs(10);                        // 延时消除按键按下的抖动
 209   3                  while(!Key1);                       // 等待按键释放
 210   3                  DelayMs(10);                        // 延时消除按键松开的抖动
 211   3              }
 212   2      
 213   2              /* 亮度控制 */
 214   2              if(LED==1)                                                      // 如果LED是灭的
 215   2              {
 216   3                  ManualControl();                    // 则进行手动控制
 217   3              }
 218   2              else                                                                            // 如果LED是亮的
 219   2              {
 220   3                  if(gTime<10000)
 221   3                  {
 222   4                      ret=Get_ADC0832();              // 获取AD采集结果(环境光照强度)
 223   4                      AutoControl(ret);                       // 进行自动控制
 224   4                      DelayMs(200);
 225   4                  }
 226   3              }
 227   2      
 228   2              /*检测是否有人*/
 229   2              if(Module==1)
 230   2              {
 231   3                  gTime=0;                                                                            // 检测到有人，则把10秒计时清零
 232   3              }
 233   2              if(gTime>10000)                                                         // 如果gTime的值超过了10000
 234   2              {
 235   3                  gTime=10000;                                                                // 则把gTime的值重新赋值为10000，避免过大溢出
 236   3                  gIndex=0;                                                                           // 如果10秒检测不到有人，则把台灯熄灭
 237   3              }
 238   2          }
 239   1      }
 240          
 241          
C51 COMPILER V9.00   MAIN                                                                  05/05/2023 21:19:00 PAGE 5   

 242          /*********************************************************/
 243          // 定时器0服务程序，1毫秒
 244          /*********************************************************/
 245          void Timer0(void) interrupt 1
 246          {
 247   1          TH0  = 252;                                         // 给定时器0的TH0装初值(TH0=0xfc)
 248   1          TL0  = 24;                                          // 给定时器0的TL0装初值 (TL0=0x18)
 249   1      
 250   1          gTime++;                                                    // 每1毫秒，gTime变量加1
 251   1          gCount++;                                                   // 每1毫秒，gCount变量加1
 252   1      
 253   1          if(gCount==10)                              // 如果gCount加到10了
 254   1          {
 255   2              gCount=0;                                               // 则将gCount清零，进入新一轮的计数
 256   2              if(gIndex!=0)                           // 如果说台灯不是最暗的(熄灭)
 257   2              {
 258   3                  Lamp=0;                                             // 则把台灯点亮
 259   3              }
 260   2          }
 261   1          if(gCount==gIndex)          // 如果gCount计数到和gIndex一样了
 262   1          {
 263   2              if(gIndex!=9)                           // 如果说台灯不是最亮的
 264   2              {
 265   3                  Lamp=1;                                             // 则把台灯熄灭
 266   3              }
 267   2          }
 268   1      }
 269          
 270          
 271          //串口服务的函数
 272          void time() interrupt 4
 273          {
 274   1          if(RI)
 275   1          {
 276   2              RI=0;
 277   2      
 278   2              if(SBUF=='a')//亮度减
 279   2              {
 280   3                  if(gIndex>0)                        // 只要当前亮度不为最低才能减少亮度
 281   3                  {
 282   4                      gIndex--;                               // 亮度降低一档         DelayMs(300);           // 延时0.3秒
 283   4                  }
 284   3              }
 285   2      
 286   2              if(SBUF=='b')  //亮度加
 287   2              {
 288   3                  if(gIndex<9)                        // 只要当前亮度不为最高才能增加亮度
 289   3                  {
 290   4                      gIndex++;                               // 亮度增加一档
 291   4                      //      DelayMs(300);           // 延时0.3秒
 292   4                  }
 293   3              }
 294   2      
 295   2              if(SBUF=='c') //自动模式
 296   2              {
 297   3                  LED=0;
 298   3              }
 299   2      
 300   2              if(SBUF=='d') //手动模式
 301   2              {
 302   3                  LED=1;
 303   3              }
C51 COMPILER V9.00   MAIN                                                                  05/05/2023 21:19:00 PAGE 6   

 304   2                      if(SBUF=='e') //熄灭
 305   2              {
 306   3                  gIndex=0;
 307   3              }
 308   2                      if(SBUF=='f') //最亮
 309   2              {
 310   3                  gIndex=9;
 311   3              }
 312   2      
 313   2      
 314   2          }
 315   1      }
 316          
 317          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    567    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
